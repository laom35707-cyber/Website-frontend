<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>W - ç³»ç»ŸçŠ¶æ€</title>
    <style>
        /* 1. å…¨å±€èƒŒæ™¯ */
        body { 
            margin: 0; 
            background: linear-gradient(to top, #f2f2f2 0%, #ffffff 45%, #ffffff 100%); 
            font-family: serif; 
            min-height: 100vh;
        }
        /* 2. å¯¼èˆªæ æ ·å¼ (æ‰€æœ‰é¡µé¢é€šç”¨) - å·²ä¿®æ”¹ä¸ºEmoji+æ–‡å­— */
        .nav-container { 
            position: fixed; 
            bottom: 12px; 
            left: 2%; 
            width: 96%; 
            height: 80px; 
            background: #fff; 
            border-radius: 18px; 
            border: 1px solid #e8e8e8; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            z-index: 100; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        .button-group { 
            width: 100%; 
            display: flex; 
            justify-content: space-around; 
            align-items: center; 
        }
        .nav-btn { 
            height: 50px;
            cursor: pointer; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px 12px;
            border-radius: 12px;
            transition: all 0.3s ease;
            min-width: 70px;
            /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .nav-btn:hover {
            background: rgba(0,0,0,0.03);
        }
        .nav-btn.active {
            background: rgba(0,0,0,0.05);
        }
        .nav-btn-emoji {
            font-size: 24px;
            margin-bottom: 4px;
            line-height: 1;
            /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .nav-btn-text {
            font-size: 12px;
            font-weight: 500;
            color: #333;
            letter-spacing: 0.5px;
            /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .nav-btn.active .nav-btn-text {
            color: #000;
            font-weight: 600;
        }

        /* 3. åŸwé¡µé¢æ ·å¼ */
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
        }
        
        .w-body-content {
            background: transparent; 
            font-family: "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", serif;
            color: #000;
            overflow-x: hidden;
            overflow-y: auto;
            padding-bottom: 120px; /* ç»™åº•éƒ¨å¯¼èˆªç•™ç©ºé—´ */
        }

        /* é¡¶éƒ¨é£æ™¯å›¾ï¼šåˆ‡ä¸€åŠæ•ˆæœ */
        .header-banner {
            width: 100%;
            height: 40vh;
            background: url('res/w/header.jpg') no-repeat center center;
            background-size: cover;
            /* ç»™åº•éƒ¨åšä¸€ç‚¹ç‚¹åœ†è§’ï¼Œå¢åŠ ç²¾è‡´æ„Ÿ */
            border-bottom-left-radius: 20px;
            border-bottom-right-radius: 20px;
        }

        /* èµ„æ–™å¡ç‰‡ */
        .profile-container {
            padding: 0 20px;
            margin-top: -50px; /* è®©å¤´åƒå¾€ä¸Šæµ®åŠ¨ä¸€ç‚¹ */
        }

        .avatar {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            border: 4px solid #fff; /* çº¯ç™½æè¾¹ï¼Œéå¸¸å…³é”® */
            background: url('res/w/avatar.jpg') no-repeat center center;
            background-size: cover;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }

        .motto {
            margin: 15px 0 30px 5px;
            font-size: 1.3rem;
            font-weight: 500;
            letter-spacing: 1px;
            /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* æ•°æ®è¡Œï¼šæ¨¡ä»¿èµ„æ–™å¡çš„ç²¾è‡´æ„Ÿ */
        .data-card {
            background: rgba(255, 255, 255, 0.9); /* åŠé€æ˜ç™½ï¼Œèƒ½é€å‡ºèƒŒæ™¯æ¸å˜ */
            border-radius: 20px;
            padding: 10px 20px;
            border: 1px solid rgba(0,0,0,0.05);
            margin-bottom: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .data-card-title {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 12px;
            text-align: center;
            font-weight: 600;
            /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .data-item {
            display: flex;
            justify-content: space-between;
            padding: 16px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .data-item:last-child { 
            border-bottom: none; 
        }

        .label { 
            color: #666; 
            font-size: 0.9rem; 
            display: flex;
            align-items: center;
            /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .value { 
            font-weight: bold; 
            font-family: 'Courier New', Courier, monospace; 
            font-size: 1rem;
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .status-online {
            background: #27ae60;
        }

        .status-offline {
            background: #e74c3c;
            animation: none;
            opacity: 0.5;
        }

        .status-warning {
            background: #f39c12;
        }

        /* è¿æ¥çŠ¶æ€æ ·å¼ */
        .connection-status {
            display: flex;
            align-items: center;
        }

        .connection-good { color: #27ae60; }
        .connection-fair { color: #f39c12; }
        .connection-poor { color: #e74c3c; }

        /* æ•°æ®åŠ è½½åŠ¨ç”» */
        .loading {
            color: #999 !important;
            font-style: italic;
        }

        .loading::after {
            content: '...';
            animation: loadingDots 1.5s infinite;
        }

        @keyframes loadingDots {
            0%, 20% { content: '.'; }
            40%, 60% { content: '..'; }
            80%, 100% { content: '...'; }
        }

        /* çŠ¶æ€æ ‡ç­¾ */
        .status-tag {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            font-weight: bold;
            margin-left: 8px;
        }

        .status-tag-good {
            background: rgba(39, 174, 96, 0.1);
            color: #27ae60;
        }

        .status-tag-warning {
            background: rgba(243, 156, 18, 0.1);
            color: #f39c12;
        }

        .status-tag-poor {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
        }

        /* äº‘æœµå›¾æ ‡ */
        .cloud-icon {
            font-size: 0.8em;
            margin-right: 4px;
            opacity: 0.7;
            /* ç¦æ­¢æ–‡æœ¬é€‰æ‹© */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* è°ƒè¯•ä¿¡æ¯æ ·å¼ */
        .debug-info {
            font-size: 0.7rem;
            color: #999;
            font-family: monospace;
            margin-top: 4px;
            display: block;
        }
    </style>
</head>
<body>
    <!-- é¡µé¢å†…å®¹å®¹å™¨ -->
    <div class="w-body-content">
        <div class="header-banner"></div>

        <div class="profile-container">
            <div class="avatar"></div>
            <h2 class="motto">ç¥æˆ‘å¤©å¤©å¼€å¿ƒ</h2>

            <!-- Cloudflare çŠ¶æ€å¡ç‰‡ -->
            <div class="data-card">
                <div class="data-card-title">â˜ï¸ ç½‘ç»œçŠ¶æ€</div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">â˜ï¸</span>è¿è¡ŒçŠ¶æ€
                    </span>
                    <span class="value connection-status">
                        <span class="status-indicator status-online" id="cf-status-indicator"></span>
                        <span id="cf-status-text">æ£€æµ‹ä¸­</span>
                        <span id="cf-status-tag" class="status-tag status-tag-good" style="display:none;">åœ¨çº¿</span>
                        <!-- è°ƒè¯•ä¿¡æ¯ -->
                        <small id="cf-debug" class="debug-info" style="display:none;"></small>
                    </span>
                </div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">ğŸŒ</span>CDN èŠ‚ç‚¹
                    </span>
                    <span class="value" id="cf-colo">æ£€æµ‹ä¸­...</span>
                </div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">âš¡</span>è¾¹ç¼˜ç¼“å­˜
                    </span>
                    <span class="value" id="cf-cache-status">æ£€æµ‹ä¸­...</span>
                </div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">ğŸ›¡ï¸</span>å®‰å…¨é˜²æŠ¤
                    </span>
                    <span class="value" id="cf-security">æ£€æµ‹ä¸­...</span>
                </div>
            </div>

            <!-- ç³»ç»Ÿæ€§èƒ½å¡ç‰‡ -->
            <div class="data-card">
                <div class="data-card-title">ğŸ“Š æ€§èƒ½æ•°æ®</div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">ğŸ“…</span>è¿è¡Œå¤©æ•°
                    </span>
                    <span class="value" id="days">Counting...</span>
                </div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">â±ï¸</span>é¡µé¢åŠ è½½
                    </span>
                    <span class="value" id="page-load">æ£€æµ‹ä¸­...</span>
                </div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">ğŸ“ˆ</span>æ€§èƒ½è¯„åˆ†
                    </span>
                    <span class="value" id="performance-score">æ£€æµ‹ä¸­...</span>
                </div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">ğŸ”—</span>ç½‘ç»œå»¶è¿Ÿ
                    </span>
                    <span class="value connection-status" id="network-ping">
                        <span>æ£€æµ‹ä¸­...</span>
                    </span>
                </div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">ğŸ’¾</span>æµè§ˆå™¨å†…å­˜
                    </span>
                    <span class="value" id="browser-memory">æ£€æµ‹ä¸­...</span>
                </div>
                <div class="data-item">
                    <span class="label">
                        <span class="cloud-icon">ğŸ”„</span>è¯·æ±‚çŠ¶æ€
                    </span>
                    <span class="value" id="request-status">ç­‰å¾…ä¸­...</span>
                </div>
            </div>

            <!-- æ‰©å±•ä¿¡æ¯ -->
            <div class="data-card">
                <div class="data-card-title">ğŸ” è¯¦ç»†ä¿¡æ¯</div>
                <div class="data-item">
                    <span class="label">User Agent</span>
                    <span class="value" id="user-agent" style="font-size:0.8rem;max-width:60%;text-align:right;word-break:break-all;"></span>
                </div>
                <div class="data-item">
                    <span class="label">æ—¶åŒº</span>
                    <span class="value" id="timezone">æ£€æµ‹ä¸­...</span>
                </div>
                <div class="data-item">
                    <span class="label">æœ€åæ›´æ–°</span>
                    <span class="value" id="last-update">--:--:--</span>
                </div>
            </div>
        </div>
    </div>

    <!-- å¯¼èˆªæ  - å·²ä¿®æ”¹ä¸ºEmoji+æ–‡å­— -->
    <div class="nav-container">
        <div class="button-group">
            <div class="nav-btn" onclick="location.href='index.html'">
                <div class="nav-btn-emoji">ğŸ </div>
                <div class="nav-btn-text">é¦–é¡µ</div>
            </div>
            <div class="nav-btn" onclick="location.href='study.html'">
                <div class="nav-btn-emoji">ğŸ“š</div>
                <div class="nav-btn-text">å­¦ä¹ </div>
            </div>
            <div class="nav-btn" onclick="location.href='diary.html'">
                <div class="nav-btn-emoji">ğŸ“</div>
                <div class="nav-btn-text">æ—¥è®°</div>
            </div>
            <div class="nav-btn active" onclick="location.href='w.html'">
                <div class="nav-btn-emoji">ğŸ“Š</div>
                <div class="nav-btn-text">çŠ¶æ€</div>
            </div>
        </div>
    </div>

    <script>
        // Cloudflare çŠ¶æ€æ£€æµ‹ç±» - ä¼˜åŒ–ç‰ˆæœ¬
        class CloudflareMonitor {
            constructor() {
                this.cfData = {};
                this.isCF = false;
                this.lastUpdate = new Date();
                this.retryCount = 0;
                this.maxRetries = 2;
            }

            // æ£€æµ‹æ˜¯å¦åœ¨Cloudflareä¸Šè¿è¡Œï¼ˆå¤šæ–¹æ³•æ£€æµ‹ï¼‰
            async detectCloudflare() {
                const detectionMethods = [
                    this._detectViaTraceEndpoint.bind(this),
                    this._detectViaHeaders.bind(this),
                    this._detectViaHostname.bind(this),
                    this._detectViaPing.bind(this)
                ];

                // æŒ‰é¡ºåºå°è¯•æ‰€æœ‰æ£€æµ‹æ–¹æ³•
                for (let i = 0; i < detectionMethods.length; i++) {
                    try {
                        const result = await detectionMethods[i]();
                        if (result) {
                            console.log(`âœ… æ–¹æ³•${i+1}æ£€æµ‹åˆ°Cloudflare:`, this.cfData);
                            this.isCF = true;
                            return true;
                        }
                    } catch (error) {
                        console.log(`æ–¹æ³•${i+1}æ£€æµ‹å¤±è´¥:`, error.message);
                    }
                }

                console.log('âŒ æ‰€æœ‰æ£€æµ‹æ–¹æ³•å‡å¤±è´¥ï¼Œæœªæ£€æµ‹åˆ°Cloudflare');
                this.isCF = false;
                return false;
            }

            // æ–¹æ³•1: é€šè¿‡traceç«¯ç‚¹æ£€æµ‹
            async _detectViaTraceEndpoint() {
                try {
                    const response = await fetch('https://1.1.1.1/cdn-cgi/trace', {
                        method: 'GET',
                        cache: 'no-store',
                        mode: 'cors',
                        headers: { 'Accept': 'text/plain' }
                    });
                    
                    if (response.ok) {
                        const text = await response.text();
                        const lines = text.split('\n');
                        const data = {};
                        
                        lines.forEach(line => {
                            const [key, value] = line.split('=');
                            if (key && value) data[key] = value;
                        });
                        
                        if (data.fl) { // flå­—æ®µå­˜åœ¨è¡¨ç¤ºåœ¨Cloudflareç½‘ç»œä¸­
                            this.cfData = {
                                colo: data.colo || 'æœªçŸ¥',
                                cacheStatus: 'æ´»è·ƒ',
                                securityLevel: 'å·²ä¿æŠ¤',
                                ip: data.ip || 'æœªçŸ¥',
                                loc: data.loc || 'æœªçŸ¥',
                                tls: data.tls || 'æœªçŸ¥',
                                uag: data.uag || 'æœªçŸ¥',
                                method: 'trace'
                            };
                            return true;
                        }
                    }
                } catch (error) {
                    throw new Error(`Traceæ£€æµ‹å¤±è´¥: ${error.message}`);
                }
                return false;
            }

            // æ–¹æ³•2: é€šè¿‡headersæ£€æµ‹
            async _detectViaHeaders() {
                try {
                    const response = await fetch(window.location.origin, {
                        method: 'HEAD',
                        credentials: 'same-origin',
                        cache: 'no-store'
                    });
                    
                    const headers = response.headers;
                    const cfHeaders = {
                        ray: headers.get('cf-ray'),
                        server: headers.get('server'),
                        cacheStatus: headers.get('cf-cache-status'),
                        colo: headers.get('cf-colo'),
                        country: headers.get('cf-ipcountry'),
                        visitor: headers.get('cf-visitor')
                    };
                    
                    // å¦‚æœæœ‰CFç›¸å…³headerï¼Œåˆ™è®¤ä¸ºæ˜¯Cloudflare
                    if (cfHeaders.ray || (cfHeaders.server && cfHeaders.server.includes('cloudflare'))) {
                        this.cfData = {
                            colo: cfHeaders.colo || 'æœªçŸ¥',
                            cacheStatus: cfHeaders.cacheStatus || 'åŠ¨æ€',
                            securityLevel: cfHeaders.country ? 'å·²ä¿æŠ¤' : 'åŸºç¡€',
                            rayId: cfHeaders.ray || 'æ— ',
                            country: cfHeaders.country || 'æœªçŸ¥',
                            method: 'headers'
                        };
                        return true;
                    }
                } catch (error) {
                    throw new Error(`Headersæ£€æµ‹å¤±è´¥: ${error.message}`);
                }
                return false;
            }

            // æ–¹æ³•3: é€šè¿‡hostnameæ£€æµ‹
            async _detectViaHostname() {
                const hostname = window.location.hostname;
                const cfDomains = [
                    '.workers.dev',
                    '.pages.dev',
                    '.cloudflare.com',
                    '.cloudflarestorage.com'
                ];
                
                for (const domain of cfDomains) {
                    if (hostname.endsWith(domain) || hostname.includes('cloudflare')) {
                        this.cfData = {
                            colo: 'Cloudflareç½‘ç»œ',
                            cacheStatus: 'é¡µé¢æœåŠ¡',
                            securityLevel: 'åŸºç¡€é˜²æŠ¤',
                            method: 'hostname'
                        };
                        return true;
                    }
                }
                return false;
            }

            // æ–¹æ³•4: é€šè¿‡pingæ£€æµ‹
            async _detectViaPing() {
                try {
                    // å°è¯•ping Cloudflareç‰¹å®šç«¯ç‚¹
                    const endpoints = [
                        'https://cloudflare.com/favicon.ico',
                        'https://www.cloudflare.com/favicon.ico',
                        'https://dash.cloudflare.com/favicon.ico'
                    ];
                    
                    for (const endpoint of endpoints) {
                        try {
                            const startTime = performance.now();
                            const response = await fetch(endpoint, {
                                method: 'HEAD',
                                mode: 'no-cors'
                            });
                            const latency = performance.now() - startTime;
                            
                            if (latency < 5000) { // 5ç§’å†…å“åº”
                                this.cfData = {
                                    colo: 'å¤–éƒ¨æ£€æµ‹',
                                    cacheStatus: 'ç½‘ç»œå¯è¾¾',
                                    securityLevel: 'é—´æ¥æ£€æµ‹',
                                    latency: Math.round(latency),
                                    method: 'ping'
                                };
                                return true;
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                } catch (error) {
                    throw new Error(`Pingæ£€æµ‹å¤±è´¥: ${error.message}`);
                }
                return false;
            }

            // è·å–CloudflareçŠ¶æ€ï¼ˆç®€åŒ–ç‰ˆï¼‰
            async getCloudflareStatus() {
                // æ˜¾ç¤ºå‹å¥½çŠ¶æ€ï¼Œä¸å¼ºåˆ¶ä¾èµ–å¤–éƒ¨API
                if (!this.isCF) {
                    return {
                        online: true, // å³ä½¿ä¸åœ¨Cloudflareä¸Šï¼Œåªè¦é¡µé¢èƒ½è®¿é—®å°±æ˜¾ç¤ºåœ¨çº¿
                        status: 'æ­£å¸¸',
                        message: 'æœåŠ¡è¿è¡Œä¸­',
                        fallback: true
                    };
                }

                try {
                    // ç®€åŒ–æ£€æµ‹ï¼šåªè¦èƒ½è®¿é—®é¡µé¢å°±ç®—æ­£å¸¸
                    const startTime = performance.now();
                    const response = await fetch(window.location.pathname, {
                        method: 'HEAD',
                        cache: 'no-cache',
                        credentials: 'same-origin'
                    });
                    const latency = Math.round(performance.now() - startTime);
                    
                    return {
                        online: response.ok,
                        latency: latency,
                        status: response.ok ? 'åœ¨çº¿' : 'æœåŠ¡å¼‚å¸¸',
                        code: response.status,
                        colo: response.headers.get('cf-colo') || this.cfData.colo
                    };
                } catch (error) {
                    // å¦‚æœå¤±è´¥ï¼Œè¿”å›é™çº§çŠ¶æ€
                    return {
                        online: false,
                        status: 'ç½‘ç»œé”™è¯¯',
                        message: error.message,
                        fallback: true
                    };
                }
            }

            // è·å–ç¼“å­˜çŠ¶æ€
            getCacheStatus() {
                if (!this.isCF) return 'ğŸŒ ç›´è¿æœåŠ¡å™¨';
                
                const status = this.cfData.cacheStatus || 'åŠ¨æ€';
                const statusMap = {
                    'HIT': 'âœ… ç¼“å­˜å‘½ä¸­',
                    'MISS': 'ğŸ”„ ç¼“å­˜æœªå‘½ä¸­',
                    'EXPIRED': 'ğŸ”„ ç¼“å­˜è¿‡æœŸ',
                    'STALE': 'ğŸ”„ ç¼“å­˜é™ˆæ—§',
                    'BYPASS': 'ğŸ”„ ç»•è¿‡ç¼“å­˜',
                    'DYNAMIC': 'âš¡ åŠ¨æ€å†…å®¹',
                    'åŠ¨æ€': 'âš¡ åŠ¨æ€å†…å®¹',
                    'æ´»è·ƒ': 'âœ… ç¼“å­˜æ´»è·ƒ',
                    'é¡µé¢æœåŠ¡': 'ğŸ“„ é¡µé¢æœåŠ¡'
                };
                
                return statusMap[status] || status || 'ğŸ”„ ç¼“å­˜ä¸­';
            }

            // è·å–å®‰å…¨çŠ¶æ€
            getSecurityStatus() {
                if (!this.isCF) return 'ğŸ›¡ï¸ åŸºç¡€é˜²æŠ¤';
                
                const level = this.cfData.securityLevel || '';
                if (level.includes('å·²ä¿æŠ¤') || level.includes('åŸºç¡€é˜²æŠ¤')) {
                    return 'âœ… å®‰å…¨é˜²æŠ¤';
                } else if (level.includes('é«˜é£é™©')) {
                    return 'âš ï¸ éœ€å…³æ³¨';
                }
                
                return 'ğŸ›¡ï¸ é˜²æŠ¤ä¸­';
            }

            // è·å–èŠ‚ç‚¹ä¿¡æ¯
            getColoInfo() {
                if (!this.isCF) return 'ğŸŒ ç›´è¿æœåŠ¡å™¨';
                
                const colo = this.cfData.colo || '';
                const coloMap = {
                    'HKG': 'ğŸ‡­ğŸ‡° é¦™æ¸¯èŠ‚ç‚¹',
                    'SIN': 'ğŸ‡¸ğŸ‡¬ æ–°åŠ å¡èŠ‚ç‚¹',
                    'TYO': 'ğŸ‡¯ğŸ‡µ ä¸œäº¬èŠ‚ç‚¹',
                    'ICN': 'ğŸ‡°ğŸ‡· é¦–å°”èŠ‚ç‚¹',
                    'LAX': 'ğŸ‡ºğŸ‡¸ æ´›æ‰çŸ¶èŠ‚ç‚¹',
                    'SFO': 'ğŸ‡ºğŸ‡¸ æ—§é‡‘å±±èŠ‚ç‚¹',
                    'DFW': 'ğŸ‡ºğŸ‡¸ è¾¾æ‹‰æ–¯èŠ‚ç‚¹',
                    'ORD': 'ğŸ‡ºğŸ‡¸ èŠåŠ å“¥èŠ‚ç‚¹',
                    'LHR': 'ğŸ‡¬ğŸ‡§ ä¼¦æ•¦èŠ‚ç‚¹',
                    'FRA': 'ğŸ‡©ğŸ‡ª æ³•å…°å…‹ç¦èŠ‚ç‚¹',
                    'AMS': 'ğŸ‡³ğŸ‡± é˜¿å§†æ–¯ç‰¹ä¸¹èŠ‚ç‚¹',
                    'SYD': 'ğŸ‡¦ğŸ‡º æ‚‰å°¼èŠ‚ç‚¹',
                    'Cloudflareç½‘ç»œ': 'ğŸŒ Cloudflareç½‘ç»œ',
                    'å¤–éƒ¨æ£€æµ‹': 'ğŸ“¡ å¤–éƒ¨ç½‘ç»œ',
                    'æœªçŸ¥': 'ğŸŒ å…¨çƒèŠ‚ç‚¹'
                };
                
                return coloMap[colo] || (colo ? `ğŸŒ ${colo}` : 'ğŸŒ å…¨çƒç½‘ç»œ');
            }

            // è·å–è°ƒè¯•ä¿¡æ¯
            getDebugInfo() {
                return JSON.stringify({
                    isCF: this.isCF,
                    data: this.cfData,
                    method: this.cfData.method,
                    time: new Date().toLocaleTimeString()
                }, null, 2);
            }
        }

        // ç³»ç»Ÿæ€§èƒ½ç›‘æ§ç±» - ä¼˜åŒ–ç‰ˆæœ¬
        class SystemMonitor {
            constructor() {
                this.metrics = {};
                this.cfMonitor = new CloudflareMonitor();
                this.initialized = false;
                this.updateInterval = null;
                this.performanceData = {
                    startTime: Date.now(),
                    pageLoadTime: 0,
                    updateCount: 0
                };
            }

            // åˆå§‹åŒ–
            async initialize() {
                if (this.initialized) return;
                
                console.log('ğŸ”„ åˆå§‹åŒ–ç³»ç»Ÿç›‘æ§...');
                
                // æ˜¾ç¤ºåˆå§‹çŠ¶æ€
                this.showLoading();
                
                // æ›´æ–°åŸºç¡€ä¿¡æ¯
                this.updateBasicInfo();
                
                // å¼€å¯è°ƒè¯•æ¨¡å¼ï¼ˆå¦‚æœURLä¸­æœ‰debugå‚æ•°ï¼‰
                this.enableDebugMode();
                
                // å»¶è¿Ÿæ£€æµ‹Cloudflareï¼ˆé¿å…é˜»å¡é¡µé¢åŠ è½½ï¼‰
                setTimeout(async () => {
                    try {
                        console.log('å¼€å§‹æ£€æµ‹Cloudflare...');
                        const isCF = await this.cfMonitor.detectCloudflare();
                        
                        console.log('Cloudflareæ£€æµ‹ç»“æœ:', {
                            isCF: isCF,
                            data: this.cfMonitor.cfData
                        });
                        
                        // æ›´æ–°UIçŠ¶æ€
                        await this.updateCloudflareStatus();
                        
                        // æ›´æ–°ç¼“å­˜å’ŒèŠ‚ç‚¹ä¿¡æ¯
                        document.getElementById('cf-cache-status').textContent = 
                            this.cfMonitor.getCacheStatus();
                        document.getElementById('cf-security').textContent = 
                            this.cfMonitor.getSecurityStatus();
                        document.getElementById('cf-colo').textContent = 
                            this.cfMonitor.getColoInfo();
                        
                        // æ˜¾ç¤ºæ£€æµ‹æ–¹æ³•
                        if (window.debugMode) {
                            const debugEl = document.getElementById('cf-debug');
                            debugEl.textContent = `æ£€æµ‹æ–¹å¼: ${this.cfMonitor.cfData.method || 'æœªçŸ¥'}`;
                        }
                        
                    } catch (error) {
                        console.error('Cloudflareæ£€æµ‹å¼‚å¸¸:', error);
                        this.showError('æ£€æµ‹å¼‚å¸¸ï¼Œä½¿ç”¨æœ¬åœ°æ¨¡å¼');
                    }
                }, 500);
                
                // åˆå§‹æ›´æ–°æ‰€æœ‰æŒ‡æ ‡
                setTimeout(async () => {
                    await this.updateAllMetrics();
                    this.initialized = true;
                    console.log('âœ… ç³»ç»Ÿç›‘æ§åˆå§‹åŒ–å®Œæˆ');
                }, 1000);
                
                // è®¾ç½®è‡ªåŠ¨æ›´æ–°
                this.setupAutoUpdate();
            }

            // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
            showLoading() {
                document.getElementById('cf-status-text').textContent = 'æ£€æµ‹ä¸­...';
                document.getElementById('cf-status-indicator').className = 
                    'status-indicator status-warning';
                
                // ä¸ºå…¶ä»–é¡¹ç›®æ·»åŠ åŠ è½½åŠ¨ç”»
                const loadingItems = ['cf-colo', 'cf-cache-status', 'cf-security'];
                loadingItems.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.classList.add('loading');
                });
            }

            // æ˜¾ç¤ºé”™è¯¯çŠ¶æ€
            showError(message) {
                document.getElementById('cf-status-text').textContent = message;
                document.getElementById('cf-status-indicator').className = 
                    'status-indicator status-offline';
                document.getElementById('cf-status-tag').textContent = 'æœ¬åœ°';
                document.getElementById('cf-status-tag').className = 'status-tag status-tag-warning';
                document.getElementById('cf-status-tag').style.display = 'inline-block';
                
                // ç§»é™¤åŠ è½½åŠ¨ç”»
                const loadingItems = ['cf-colo', 'cf-cache-status', 'cf-security'];
                loadingItems.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.classList.remove('loading');
                });
            }

            // å¼€å¯è°ƒè¯•æ¨¡å¼
            enableDebugMode() {
                const urlParams = new URLSearchParams(window.location.search);
                const isDebug = urlParams.has('debug') || 
                               window.location.hostname.includes('localhost') ||
                               window.location.hostname.includes('127.0.0.1');
                
                if (isDebug) {
                    window.debugMode = true;
                    document.getElementById('cf-debug').style.display = 'block';
                    console.log('ğŸ”§ è°ƒè¯•æ¨¡å¼å·²å¼€å¯');
                }
            }

            // æ›´æ–°åŸºç¡€ä¿¡æ¯
            updateBasicInfo() {
                try {
                    // è¿è¡Œå¤©æ•°
                    const start = new Date('2026-02-10');
                    const now = new Date();
                    const days = Math.floor((now - start) / (1000*60*60*24));
                    document.getElementById('days').textContent = 
                        days > 0 ? `${days} å¤©` : 'ä»Šå¤©';
                    
                    // User Agent
                    const ua = navigator.userAgent;
                    document.getElementById('user-agent').textContent = 
                        ua.length > 50 ? ua.substring(0, 50) + '...' : ua;
                    
                    // æ—¶åŒº
                    document.getElementById('timezone').textContent = 
                        Intl.DateTimeFormat().resolvedOptions().timeZone;
                        
                } catch (error) {
                    console.warn('æ›´æ–°åŸºç¡€ä¿¡æ¯å¤±è´¥:', error);
                }
            }

            // æ›´æ–°é¡µé¢æ€§èƒ½
            updatePagePerformance() {
                try {
                    if (window.performance && performance.timing) {
                        const timing = performance.timing;
                        
                        // é¡µé¢åŠ è½½æ—¶é—´
                        if (timing.loadEventEnd > 0) {
                            const loadTime = timing.loadEventEnd - timing.navigationStart;
                            this.performanceData.pageLoadTime = loadTime;
                            
                            document.getElementById('page-load').textContent = 
                                `${Math.round(loadTime)}ms`;
                            
                            // æ€§èƒ½è¯„åˆ†
                            let score = 100;
                            if (loadTime > 3000) score = 60;
                            else if (loadTime > 2000) score = 70;
                            else if (loadTime > 1000) score = 80;
                            else if (loadTime > 500) score = 90;
                            
                            const scoreElement = document.getElementById('performance-score');
                            scoreElement.textContent = `${score}/100`;
                            scoreElement.className = `value ${
                                score >= 90 ? 'connection-good' : 
                                score >= 70 ? 'connection-fair' : 
                                'connection-poor'
                            }`;
                        }
                    }
                } catch (error) {
                    console.warn('æ›´æ–°é¡µé¢æ€§èƒ½å¤±è´¥:', error);
                }
            }

            // æ›´æ–°ç½‘ç»œå»¶è¿Ÿ
            async updateNetworkPing() {
                try {
                    const startTime = performance.now();
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 5000);
                    
                    // ä½¿ç”¨å¤šç§ç«¯ç‚¹å°è¯•
                    const endpoints = [
                        'https://1.1.1.1/cdn-cgi/trace',
                        window.location.origin + '/favicon.ico?' + Date.now(),
                        'https://www.google.com/favicon.ico'
                    ];
                    
                    let success = false;
                    let ping = 0;
                    
                    for (const endpoint of endpoints) {
                        try {
                            await fetch(endpoint, {
                                method: 'HEAD',
                                mode: 'no-cors',
                                signal: controller.signal,
                                cache: 'no-store'
                            });
                            ping = Math.round(performance.now() - startTime);
                            success = true;
                            break;
                        } catch (e) {
                            continue;
                        }
                    }
                    
                    clearTimeout(timeoutId);
                    
                    const pingElement = document.getElementById('network-ping');
                    if (success) {
                        pingElement.innerHTML = `<span>${ping}ms</span>`;
                        pingElement.className = `value connection-status ${
                            ping < 100 ? 'connection-good' : 
                            ping < 300 ? 'connection-fair' : 
                            'connection-poor'
                        }`;
                    } else {
                        pingElement.innerHTML = '<span>è¶…æ—¶</span>';
                        pingElement.className = 'value connection-status connection-poor';
                    }
                    
                } catch (error) {
                    console.warn('æ›´æ–°ç½‘ç»œå»¶è¿Ÿå¤±è´¥:', error);
                    document.getElementById('network-ping').innerHTML = 
                        '<span>--</span>';
                }
            }

            // æ›´æ–°æµè§ˆå™¨å†…å­˜
            updateBrowserMemory() {
                try {
                    if (performance && performance.memory) {
                        const memory = performance.memory;
                        const usedMB = Math.round(memory.usedJSHeapSize / (1024 * 1024));
                        const totalMB = Math.round(memory.totalJSHeapSize / (1024 * 1024));
                        const limitMB = Math.round(memory.jsHeapSizeLimit / (1024 * 1024));
                        
                        document.getElementById('browser-memory').textContent = 
                            `${usedMB}MB / ${totalMB}MB`;
                            
                        // æ·»åŠ é¢œè‰²æç¤º
                        const memoryElement = document.getElementById('browser-memory');
                        const usagePercent = Math.round((usedMB / totalMB) * 100);
                        
                        if (usagePercent > 90) {
                            memoryElement.className = 'value connection-poor';
                        } else if (usagePercent > 70) {
                            memoryElement.className = 'value connection-fair';
                        } else {
                            memoryElement.className = 'value connection-good';
                        }
                        
                        return { usedMB, totalMB, limitMB, usagePercent };
                    } else {
                        document.getElementById('browser-memory').textContent = 
                            'N/A';
                    }
                } catch (error) {
                    console.warn('æ›´æ–°æµè§ˆå™¨å†…å­˜å¤±è´¥:', error);
                }
                return null;
            }

            // æ›´æ–°CloudflareçŠ¶æ€
            async updateCloudflareStatus() {
                try {
                    const cfStatus = await this.cfMonitor.getCloudflareStatus();
                    const statusIndicator = document.getElementById('cf-status-indicator');
                    const statusText = document.getElementById('cf-status-text');
                    const statusTag = document.getElementById('cf-status-tag');
                    
                    // æ›´æ–°çŠ¶æ€æŒ‡ç¤ºå™¨
                    if (cfStatus.online) {
                        statusIndicator.className = 'status-indicator status-online';
                        statusText.textContent = cfStatus.status || 'åœ¨çº¿';
                        statusTag.className = 'status-tag status-tag-good';
                        statusTag.textContent = 'æ­£å¸¸';
                        statusTag.style.display = 'inline-block';
                    } else {
                        statusIndicator.className = 'status-indicator status-offline';
                        statusText.textContent = cfStatus.message || 'ç¦»çº¿';
                        statusTag.className = 'status-tag status-tag-poor';
                        statusTag.textContent = 'å¼‚å¸¸';
                        statusTag.style.display = 'inline-block';
                    }
                    
                    // æ˜¾ç¤ºå»¶è¿Ÿä¿¡æ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                    if (cfStatus.latency && window.debugMode) {
                        const debugEl = document.getElementById('cf-debug');
                        if (debugEl) {
                            debugEl.textContent = `å»¶è¿Ÿ: ${cfStatus.latency}ms | æ–¹å¼: ${this.cfMonitor.cfData.method || 'æœªçŸ¥'}`;
                        }
                    }
                    
                } catch (error) {
                    console.error('æ›´æ–°CloudflareçŠ¶æ€å¤±è´¥:', error);
                    this.showError('çŠ¶æ€æ›´æ–°å¤±è´¥');
                }
            }

            // æ›´æ–°è¯·æ±‚çŠ¶æ€
            updateRequestStatus() {
                try {
                    const now = new Date();
                    const hour = now.getHours();
                    const minute = now.getMinutes();
                    const second = now.getSeconds();
                    
                    let status = 'æ­£å¸¸';
                    let className = 'connection-good';
                    
                    // æ ¹æ®æ—¶é—´æ¨¡æ‹Ÿä¸åŒçŠ¶æ€ï¼ˆå¯è‡ªå®šä¹‰é€»è¾‘ï¼‰
                    if (this.performanceData.updateCount % 10 === 0) {
                        status = 'åˆ·æ–°ä¸­';
                        className = 'connection-fair';
                    } else if (minute % 15 === 0) {
                        status = 'é«˜å³°æœŸ';
                        className = 'connection-fair';
                    } else if (second % 30 < 5) {
                        status = 'ä½è´Ÿè½½';
                        className = 'connection-good';
                    }
                    
                    const element = document.getElementById('request-status');
                    element.textContent = status;
                    element.className = `value ${className}`;
                    
                } catch (error) {
                    console.warn('æ›´æ–°è¯·æ±‚çŠ¶æ€å¤±è´¥:', error);
                }
            }

            // æ›´æ–°æ‰€æœ‰æŒ‡æ ‡
            async updateAllMetrics() {
                try {
                    this.performanceData.updateCount++;
                    
                    // æ›´æ–°åŸºç¡€ä¿¡æ¯
                    this.updateBasicInfo();
                    
                    // æ›´æ–°é¡µé¢æ€§èƒ½
                    this.updatePagePerformance();
                    
                    // å¹¶è¡Œæ›´æ–°ç½‘ç»œå’Œå†…å­˜
                    await Promise.all([
                        this.updateNetworkPing(),
                        Promise.resolve(this.updateBrowserMemory())
                    ]);
                    
                    // æ›´æ–°è¯·æ±‚çŠ¶æ€
                    this.updateRequestStatus();
                    
                    // æ›´æ–°æœ€åæ›´æ–°æ—¶é—´
                    const now = new Date();
                    document.getElementById('last-update').textContent = 
                        now.toLocaleTimeString('zh-CN', { 
                            hour12: false,
                            hour: '2-digit',
                            minute: '2-digit',
                            second: '2-digit'
                        });
                    
                    if (window.debugMode) {
                        console.log(`ğŸ”„ ç¬¬${this.performanceData.updateCount}æ¬¡æ›´æ–°å®Œæˆ:`, 
                            new Date().toLocaleTimeString());
                    }
                    
                } catch (error) {
                    console.error('æ›´æ–°æŒ‡æ ‡å¤±è´¥:', error);
                    
                    // æ˜¾ç¤ºé”™è¯¯ä½†ä»æ›´æ–°æ—¶é—´
                    const now = new Date();
                    document.getElementById('last-update').textContent = 
                        now.toLocaleTimeString('zh-CN') + ' (æ›´æ–°å¤±è´¥)';
                }
            }

            // è®¾ç½®è‡ªåŠ¨æ›´æ–°
            setupAutoUpdate() {
                // æ¸…é™¤å¯èƒ½å­˜åœ¨çš„æ—§å®šæ—¶å™¨
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                }
                
                // åˆå§‹å»¶è¿Ÿåå¼€å§‹æ›´æ–°
                setTimeout(() => {
                    // æ¯20ç§’æ›´æ–°ä¸€æ¬¡å®Œæ•´æ•°æ®
                    this.updateInterval = setInterval(async () => {
                        await this.updateAllMetrics();
                        
                        // æ¯3æ¬¡å®Œæ•´æ›´æ–°ï¼Œæ›´æ–°ä¸€æ¬¡CloudflareçŠ¶æ€
                        if (this.performanceData.updateCount % 3 === 0) {
                            await this.updateCloudflareStatus();
                        }
                    }, 20000);
                    
                    console.log('ğŸ”„ è‡ªåŠ¨æ›´æ–°å·²å¯åŠ¨ (20ç§’é—´éš”)');
                }, 2000);
                
                // æ·»åŠ é¡µé¢å¯è§æ€§å˜åŒ–ç›‘å¬
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        console.log('é¡µé¢å¯è§ï¼Œç«‹å³æ›´æ–°');
                        this.updateAllMetrics();
                    }
                });
                
                // æ·»åŠ çª—å£èšç„¦ç›‘å¬
                window.addEventListener('focus', () => {
                    console.log('çª—å£èšç„¦ï¼Œæ›´æ–°æ•°æ®');
                    this.updateAllMetrics();
                });
            }

            // é”€æ¯ç›‘æ§å™¨
            destroy() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
                console.log('ç›‘æ§å™¨å·²é”€æ¯');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');
            
            // åˆ›å»ºå…¨å±€ç›‘æ§å™¨å®ä¾‹
            window.systemMonitor = new SystemMonitor();
            
            // å¼€å§‹åˆå§‹åŒ–
            window.systemMonitor.initialize();
            
            // æ·»åŠ é¡µé¢å¸è½½æ—¶çš„æ¸…ç†
            window.addEventListener('beforeunload', () => {
                if (window.systemMonitor) {
                    window.systemMonitor.destroy();
                }
            });
            
            // æ·»åŠ é”™è¯¯å¤„ç†
            window.addEventListener('error', (event) => {
                console.error('å…¨å±€é”™è¯¯:', event.error);
            });
            
            // æ·»åŠ æœªå¤„ç†çš„Promiseæ‹’ç»å¤„ç†
            window.addEventListener('unhandledrejection', (event) => {
                console.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', event.reason);
            });
        });

        // æ·»åŠ æ‰‹åŠ¨åˆ·æ–°åŠŸèƒ½ï¼ˆå¯é€‰ï¼‰
        function manualRefresh() {
            if (window.systemMonitor) {
                console.log('ğŸ”„ æ‰‹åŠ¨åˆ·æ–°è¯·æ±‚');
                window.systemMonitor.updateAllMetrics();
                
                // æ˜¾ç¤ºåˆ·æ–°æç¤º
                const updateEl = document.getElementById('last-update');
                const originalText = updateEl.textContent;
                updateEl.textContent = 'åˆ·æ–°ä¸­...';
                
                setTimeout(() => {
                    updateEl.textContent = originalText;
                }, 1000);
            }
        }

        // æ·»åŠ å¿«æ·é”®æ”¯æŒï¼ˆå¯é€‰ï¼‰
        document.addEventListener('keydown', (event) => {
            if (event.ctrlKey && event.key === 'r') {
                event.preventDefault(); // é˜²æ­¢é»˜è®¤åˆ·æ–°
                manualRefresh();
            }
        });
    </script>
</body>
</html>